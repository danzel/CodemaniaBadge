Capture: Uploading a 24x12 fully black image as the first message

      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    +-----------------------------------------------
0x00|00 02 31 06 00 35 31 41 02 80 00 80 01 00 00 00 	..1..51A.€.€....
0x10|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	................
0x20|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	................
0x30|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	................
0x40|00 00 00 00 00 e1 02 31 0e 00 ff ff ff ff ff ff 	.....á.1..ÿÿÿÿÿÿ
0x50|ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 	ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
0x60|ff ff ff f0 ff f0 ff f0 ff f0 ff f0 ff f0 ff f0 	ÿÿÿðÿðÿðÿðÿðÿðÿð
0x70|ff f0 ff f0 ff f0 ff f0 ff f0 00 00 00 00 00 00 	ÿðÿðÿðÿðÿð......
0x80|00 00 00 00 00 00 00 00 00 00 5b 02 33 01       	..........[.3.

Data Contents:

First message (0x01-0x45)
    1: Always 2 (unknown)
    2: Memory address
    3: Message index (6+)
    4: Memory address (Start at 0x00, increase by 0x40 (64) each time)
5-0x45: Data part of the message
      5: Speed (0x31-0x35, '1'-'5')
      6: Message index? (First message is 0x31 '1', then 0x32 '2
      7: Scroll Mode (FIXME: Document, 0x42 - scroll, 0x41 flash, FIXME OTHERS)
      8: width of image in blocks of 12 (1: <= 12 px, 2: <= 24px, etc)
      9: 0x80, specifies that we are an image
     10: 0x00, specifies we are image block 0
     11: 0x80, image
     12: 0x01, image block 1
   0x45: CRC

Second message - Image Data (0x46-0x8A)

0x46: Always 2
0x47: Memory address (0x31 = first message)
0x48: Message index (6+8 = 14, first image (only allowed 2))
0x49: Memory address (Start at 0x00, increase by 0x40 (64) each time)
0x4A-0x79: Image data.


Image data format:

Pack 16 pixels of each row into 2 bytes (true = on). If you have no image data this wide, put false
byte 0: [ row0,col1 ... row0,col7 ]
byte 1: [ row0,col8 ... row0,col15 ]
byte 2: [ row1,col1 ... row1,col7 ]
byte 4: [ row1,col8 ... row1,col15 ]
....
byte 22: [ row11,col1 ... row11,col7 ]
byte 23: [ row11,col8 ... row11,col15 ]

Then pack the next 16 pixels in the same format then process these 24 bytes as follows:
Shift them right 4 bits (this will make them 25 bytes wide, pad with 0s where there is no data)
XOR each even bit (0, 2...) with the lower nibble of the byte 25 bytes before which has been left shifted 4 bites (so we only touch the top nibble of this byte).


Sample shifter and XOR in one go:
tempBuffer contains the 24 bytes generated by packing the 2nd lot of pixels.
buffer is the buffer we are accumulating the whole message in.

byte carryByte = 0;
for (int i = 0; i < tempBuffer.Count; i++)
{
	//Shift each byte right by 4 bits
	byte newByte = (byte) (carryByte | tempBuffer[i] >> 4);
	carryByte = (byte) (tempBuffer[i] << 4);

	//XOR each even byte with the lower half of the byte 25 bytes ago (TODO: If you did this before the shift it might make more sense)
	if (i % 2 == 0) //Hack every 2nd byte
		newByte ^= (byte)(buffer[start + i + 1] << 4);

	buffer.Add(newByte);
}
buffer.Add(carryByte); //Add the remaining 4 bits



If you make your image wider than 24px then the packer does something I haven't figured out.


Outro:
70-72: { 0x02, 0x33, 0x01 }  UNKNOWN